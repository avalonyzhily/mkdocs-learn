## 学习流水(类似笔记)

- 布隆过滤器(公开课视频学习)——bloomfilter
    - 海量数据非精确过滤的一种算法
    - 大致思想为，
        1. 通过连续多个的hash算法(,对数据集中的元素进行计算
        2. 每一个算法计算后获得的下标值，将存储数组对应位置的二进制0置为1，如果已经是1(即计算结果冲突)则不做操作
        3. 重复对所有的元素进行计算和存储操作，知道存储完毕
        4. 过滤操作，进行1的计算，判断每一个算法计算的结果位置是否为1，是则继续计算；否，则说明不存在
    - 总体思路其实就是通过一定的算法计算数据的特征下标，用二进制的0/1来表示存在与否，只要有一个特征不存在则可以排除；但是，也可能出现完全满足特征却不存在的情况(因为计算结果的下标位置会有冲突)，视为误差，减小误差需要牺牲空间代价。
    - 本例采用了google提供的工具包guava中的实现

- 单台tomcat的并发上限大致是700左右
- https加密过程
    - 建立连接时拿到证书和公钥
    - 生成随机数，通过公钥加密上传到服务器私钥解密，存起来
    - 通过随机数对称加密来传输数据
- jdk重排序 现代cpu重排序的引入
    - 数据依赖性，单线程下可以保证顺序，但是多线程不能保证
    - 控制依赖性，单线程和多线程下均不能保证
- volatile 适合一写多读的场景
    - Lock指令放在写之后的读
        - 总线锁 (旧机制,现在仍有广泛应用)
        - 缓存一致性协议 MESI机制 使用CPU嗅探来感知缓存的变化,达到同步效果
- poll,select,epoll 都是同步IO中的多路复用的模型
    - ET 和 LT 的区别在于Read_List的移除上——LT 将返回关心事件的socket放回Read_List,以便下次读取,而ET模式则不会,依靠下次事件触发
        - ET模式需要有新数据到达socket缓冲区，或者epoll_ctl触发mod或Del后再add才会触发
        - LT模式只要socket缓冲区仍然可读就行
    - 注意 ET模式不能在阻塞状态时调用，编程模型会更复杂，有死锁活socket饥饿的可能性;LT模式看上去有冗余的遍历，但实际上Socket缓冲区的数据不可能一次处理完,同时又有新的socket加入,这样几乎不会有无效遍历。
- HashMap使用红黑树是由于avl树在删除节点时，为满足严格的平衡使旋转次数过多,而红黑树牺牲了部分查询性能(因为不是严格平衡),综合了读和写的开销平衡
- JVM通过卡表记录老年代对年轻代的引用，避免ygc扫描整个老年代(还要详细了解gc的时机,写屏障和卡表)
- 新生代回收垃圾的时机
    - 首次：ygc  eden - from
    - 非首次: ygc  eden,from/to - to/from
    - ygc多次后，对象晋升，或者直接分配到old(eden不够时): eden,from - old
    - old不够时： fgc
    - metaspace不够时： fgc
