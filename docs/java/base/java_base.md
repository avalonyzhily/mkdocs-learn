### ScheduledExecutorService:
1. 用作定时任务,相比Timer的单线程执行任务更好;
2. java并发包下的类;

### Java类的复用
1. 组合——显示的在新类中放置子对象，通常适合在新类中使用现有类的功能而不是它的接口。has-a
2. 继承——使用现有类的特殊版本时，使用继承。is-a
3. 代理
4. 创建新类时，应该优先考虑使用组合，一味使用继承会减少设计的灵活性，加重设计负担。

### 多态陷阱
1. 子类的实例化会调用父类的构造器，如果在父类的构造器中调用被子类覆盖的方法，会导致调用到子类的方法，而此时子类的初始化还未完成(子类构造器还没有执行完成)，会出现意想不到的情况。
2. 因此，在构造器中尽量避免调用其他的方法，减少意外的情况发生。
3. 向上转型是安全的，向下转型是不安全的，可能抛出ClassCastException

### 协变返回类型(JAVA5以后支持)
子类中覆盖了父类的方法，其返回类型可以时父类中的方法的返回类型的子类(修改返回类型不改变方法的签名，子类覆盖的方法可以缩小返回类型的范围)，这样在向上造型时，调用该方法不会导致返回类型超出范围的情况。

### interface接口 abstract抽象类
1. 接口是类与类之间的协议，不需要提供具体实现，也不能提供具体实现，接口中只能有常量或非常量的表达式(依然是静态的)。(Java8开始，接口中可以有多个默认方法，即默认实现，间接实现多继承)

2. 接口的实现不受继承的单一限制，一个接口可以继承多个接口，这里要注意多个接口组合时要避免方法签名相同的情况，会出现混淆和错误

3. 一个类可以实现多个接口，但只能继承一个类(包括抽象类)，而且必须先继承一个类，再实现多个接口(这是同时存在继承和实现的时候)

4. 对于抽象类和接口的选择，如果要创建一个没有任何方法实现和成员的父类，应该选择接口；反之，可以选择抽象类。但是一般来说优先使用接口作为父类，来定义行为规范

5. 抽象类则可以包含一部分带实现的方法和一部分不带实现的方法声明。

6. 接口和抽象类都无法实例化。

7. 接口可以嵌套在类或接口中，类中嵌套的接口(或类)可以使private的，但这些嵌套接口的实现类都是内部类，只能在类的内部使用。(这里不是很理解意义，用法也没怎么见过)

8. 接口的经典用法——工厂模式(方法)

### adapter适配器模式
接受拥有的类型/接口，实现/继承(单一限制)需要的接口，来生成需要的类型，这里用到了代理
```
public interface Processor{
    String name();
    Object process(Object input);
}

class FilterAdapter implements Processor{
    Filter filter;
    public FilterAdapter(Filter filter){
        this.filter = filter;
    }
    public String name(){
        return filter.name();
    }
    public Object process(Object input){
        return filter.process((Waveform)input);
    }
}
```

### 接口使用的误区
只有真正有抽象需求时，才应该使用接口;否则，应该优先使用类，减少设计的复杂度。接口是重要的工具，但是不应该被滥用。(注意这里与 接口和抽象类的选择 的不同理解)

### 内部类
1. 内部类拥有外部类所有元素的访问权，包括私有的;非静态的内部类的对象，只能在与外部类的对象关联时才能创建(即是外部类的对象持有的)

2. Class.this 外部类对象的引用，Object.new 通过外部类对象实例化内部类

3. 内部类向上转型为其父类，则可以阻止依赖类型的编码，以及隐藏实现细节(私有和受保护的内部类实现模个外部公有的接口，外部可以通过接口获得该内部类的实例，但不能向下转型为该内部类)

### Java8新特性之方法作为参数传递
1. 方法引用(双冒号)——对象::实例方法,类::静态方法,等同于提供方法参数的lambda表达式,如Math::pow 等同于 (x,y)->Math.pow(x,y);类::实例方法,其第一个参数会作为调用方法的对象,如 String::compareToIgnoreCase 等同于(x,y)->x.compareToIgnoreCase(y);

2. 函数式接口——有很多类型(java.util.function包下),用于接收函数或lambda表达式,这里不能将函数视为对象,因为函数并不是继承Object的。

3. lambda表达式可以转换成函数式接口; 方法引用同样也会转换为函数式接口的实例,在重载问题上,会根据对应函数式接口的方法参数来匹配