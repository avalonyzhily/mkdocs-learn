### mysql 索引

- B-tree (多路搜索树,不是二叉树!)
  - 有效的索引查询类型如下,对于多列的复合索引,列的顺序尤其重要,只有当最左侧列精确符合(常量+次左列也满足最左前缀),索引才会生效,所以范围匹配的列之后的索引列无法使用索引。
    - 全值匹配 (所有列匹配)
    - 匹配最左前缀 (最左侧列的左前缀匹配)
    - 匹配列前缀 (最左侧列的左前缀匹配)
    - 匹配范围值 (最左侧列的值范围匹配)
    - 精确匹配一列,范围匹配紧跟的另一列 (最左侧列的精确匹配,第二列范围匹配)
    - 只访问索引的查询
- 索引的作用
  - 减少扫描的数据量
  - 避免临时表和排序
  - 随机I/O转为顺序I/O
- 多列索引
  - 多列索引是联合索引,并不是多个列上建单独索引,这样做又是反而会使得性能更差
    - mysql的5.x以后的版本有索引合并策略,会将单独的列索引合并处理,但并不一定会有正面效果,反而说明索引建得不好
      - 需要多个索引列相交时,说明需要建立多列索引,而不是多列单独建索引(WHERE 多个 AND 条件)
      - 需要多个索引列的数据做联合操作时(WHERE 多个 OR 条件),这时会消耗大量CPU和内存资源在算法的缓存、排序和合并操作上
      - 这些查询成本不被优化器关注,成为隐性的成本,导致实际成本被低估,而错误的选择使用索引,其实使用全表扫描可能更快
  - 多列索引的列顺序很重要,一般来说选择性高的列放在最前
- mysql innodb的二级索引会包含主键列
- 索引排序的列只能是第一张表的列
- innodb_stats_on_metadata参数可以控制索引统计信息更新的开关,关闭该选项,可以有效减少客户端或监控程序以及其他mysql的操作(比如analyze table)带来的索引信息采样行为,减少服务器的负担
- optimize table可以整理数据,减少索引和数据碎片,提升性能

### mysql查询性能优化

- show full processlist可以查看一个查询的状态,查询的状态在生命周期内会变化很多次,mysql的一个连接相当于一个线程
  - Sleep 线程等待用户发起请求
  - Query 线程正在执行查询或者正在将结果发送给客户端
  - Locked mysql服务器层,该线程正在等待表锁。行锁是存储引擎级别的锁,不会体现在线程状态中
  - Analyzing and statistics 线程正在收集存储引擎的统计信息,并生成查询计划
  - Copying to tmp table [on disk] 正在执行查询,并将结果复制到一个临时表(可能临时表会放在磁盘上)
  - Sorting result 线程在对结果集进行排序
  - Sending data 状态之间传送数据、生成结果集、往客户端发送数据