### 引擎选择的因素考虑

- 事务:
  - 考虑事务的,请选择InnoDB
  - 不考虑事务,且只有查询和新增操作的,可以选择MyISAM
- 备份
  - 需要在线热备份的,请选择InnoDB
- 崩溃恢复 InnoDB相比MyISAM发生崩溃的概率小,恢复速度也快。
- 特有特性
  - 聚簇索引 InnoDB
  - 地理空间搜索 myisam
- 转换表的引擎
  - 最直接的方法是使用 ALTER TABLE tablename ENGINE = enginename, 但是会有一个问题,执行时间长,因为mysql会创建新的表,然后赋值数据,可能消耗掉系统所有的I/O能力
  - 通过导入导出,使用mysqldump工具
  - 创建与查询,创建表,然后使用INSERT INTO ... SELECT

### 性能剖析的理解

- 一般有两个步骤,使用性能剖析工具,譬如Percona Toolkit
  - 测量花费的时间
  - 统计排序,将重要的排在前面
- 一般讨论两种类型的性能剖析
  - 基于执行时间的,判断是什么任务执行时间最长
  - 基于等待时间的,判断任务在什么地方阻塞时间最长
  - 这是两个不同的分析角度
- 性能剖析还是有很多信息缺失,比如
  - 值得优化的查询,并不会在剖析中给出,但是有下面的原则
    - 占总响应时间比重比较小的查询,不值得优化,即使优化,收益也不会大于比重
    - 优化的成本大于收益,就要停止优化
  - 异常情况,执行频率低导致占比低,但是每次都很慢,严重影响用户体验的,也需要优化
  - 未知的情况,好的工具能提示一些丢失的时间,比如任务的总时间和实际测量时间存在差异,可能是没有测量到的任务
  - 被掩藏的细节,工具统计的是平均值,这样可能会丢失一些个别的细节
- 对性能剖析理解不到位,所有后序剖析的讲解比较偏实操,没有具体操作所以没有做笔记。

### mysql schema和数据类型的优化

- 选择优化的数据类型
  - 更小的数据类型,这样更节省资源(磁盘,cpu缓存,cpu处理周期等),但是不能低估存储的需要,否则扩容的消耗更大
  - 简单的数据类型,减少CPU处理周期,譬如:整性的操作代价低于字符型
  - 避免NULL值,NULL对索引的影响比较大(索引统计和值比较变复杂),而且对NULL值得存储也会变大,```不过对于InnoDB引擎存储NULL值的方式不一样,如果大部分是NULL值(即稀疏数据),反而有更好的空间利用效率```
- 基本类型的讨论
  - 整数类型 TINYINT SMALLINT MEDIUMINT INT BIGINT (8,16,24,32,64位存储空间),对应的值得范围是-2^(N-1) 到 2^(N-1)-1,N为存储空间得位数,其中还有UNSIGNED属性可以限制为正数,提升一倍的上限
    - 为整数类型指定的宽度,并不会限制值得范围,只是控制了交互工具中显示字符得个数(当然如果取用了显示的字符在数据库外部进行操作,就会造成影响)
  - 实数类型 可以带有小数部分,但并不只是为了存储小数部分,可以使用DECIMAL存储超过BIGINT范围的数据
    - DECIMAL精确计算开销大,但是使用浮点数精确计算结果不准确
    - mysql内部使用DOUBLE做浮点数的计算,低版本的mysql即使使用DECIMAL,计算时也会转成DOUBLE,但是高版本已经实现了DECIMAL的高精度计算,但是开销大
  - 字符串类型
    - VACHAR、CHAR
      - 比较复杂的类型,不同引擎的实现可能不一致
      - VACHAR是变长的,适合字符串列长度比平均长度大很多,这样减少碎片;另外就是使用UTF-8这种复杂的字符集,每个字符的字节数不同
      - CHAR是定长的,适合存储短字符串,或是所有值都接近一个同一个长度的数据,譬如 md5的结果,超长的会截断(或严格模式的异常)
      - 尽量分配适当的大小来存储数据
    - BLOB和TEXT
      - 都是为了存储很大的数据来设计的
      - BLOB是二进制类型
      - TEXT是字符串类型
      - 长文本不能对全文本进行索引,只能对前面一部分字节进行索引,该长度通过max_sort_length属性配置
    - VARCHAR和ENUM类型进行关联查询时,效率会降低。
  - 日期和时间
    - DATETIME 范围大
    - TIMESTAMP 范围小
- schema设计选中的陷阱
  - 关联操作最多61张表
    - 经验法则,单个查询最好在12个表以内做关联
  - 枚举不要过度
  - 变相的枚举(SET ENUM的使用场景)
  - 有些场景使用NULL比用特定的常量更合适,尽管会增加开销和处理的复杂
- 范式和反范式
  - 范式更新更快、重复数据少、表的结构小、数据冗余少,但是通常都需要关联才能获得需要的信息
  - 反范式可以最大化避免关联、单表更有效的利用索引,但是会增加重复、冗余
- 物化视图
  - 工具之一Flexviews,可以把sql通过api转成对应的物化视图脚本
- Alter Table Modify Column这样需要创建新表,复制数据,删除旧表,耗时长。而Alter Table Alter Column 则只会修改.frm文件,速度较快。但是这两个操作并不等价(此外还有change column也是)